// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A simple shader to upscale and linearly "interpolate".
package main

func Fragment(position vec4, texCoord vec2, color vec4) vec4 {
	srcOrigin, srcSize := imageSrcRegionOnTexture()
	srcMax := srcOrigin + srcSize

	// Set up typical linear interpolation.
	srcImageSize := imageSrcTextureSize()
	halfTexel := 0.5 / srcImageSize
	tieBreaker := halfTexel / 256.0
	topLeft := clamp(texCoord-halfTexel+tieBreaker, srcOrigin, srcMax)
	bottomRight := clamp(texCoord+halfTexel+tieBreaker, srcOrigin, srcMax)

	// Get the four texels.
	a := imageSrc0UnsafeAt(topLeft)
	b := imageSrc0UnsafeAt(vec2(bottomRight.x, topLeft.y))
	c := imageSrc0UnsafeAt(vec2(topLeft.x, bottomRight.y))
	d := imageSrc0UnsafeAt(bottomRight)

	// Mix them properly.
	f := fract(topLeft * srcImageSize)

	// Reduce the blur to better match VGA-like scan line doubling.
	// With a factor of 2.0, we get 50% of the pixels as nearest and 50%
	// in the linear region. Also means that at 2x scaling or above, every
	// pixel value is guaranteed to occur unchanged _somewhere_.
	// When scaling 3x (from 360p to 1080p), this will change adjacent pixel
	// values of 0 1 to 0 1/6 5/6 1. The same can be done in ffmpeg by first
	// nearest-scaling to 2x then linear-scaling to 3x.
	f = clamp(0.5+(f-0.5)*2.0, 0.0, 1.0)
	return mix(mix(a, b, f.x), mix(c, d, f.x), f.y)

	/*
		// Scan line effect?
		row := texCoord.y * srcImageSize.y;
		angle := row * 2 * 3.1415926535;
		fAngle := 0.98 - 0.02 * cos(angle);
		mask := vec4(fAngle, fAngle, fAngle, 1.0)
		return mix(mix(a, b, f.x), mix(c, d, f.x), f.y) * mask
	*/
}
