// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A simple shader to upscale and linearly "interpolate".
package main

// Strength of the scan line effect.
// Full effect at value of 2.0 (scaled in calling code).
// As a rule of thumb, below 2x (720px) height, the effect should be left off
// because all it will do is cause Moir√©.
var ScanLineEffect float // [0.0, 2.0]

// Strength of the CRT bending effect. Matches k1 and k2 parameters of FFmpeg lenscorrection.
var CRTK1, CRTK2 float

func crtMap(srcOrigin, srcSize, srcImageSize, in vec2) vec2 {
	// mapVec chosen so that diagonal has length "CRTStrength".
	// also correct for aspect.
	// I.e.:
	// length(srcSize * 0.5 * mapVec) == 1.
	// mapVec.x / mapVec.y = srcImageSize.x / srcImageSize.y
	mapVec := srcImageSize / (0.5 * length(srcImageSize*srcSize))
	srcMid := srcOrigin + srcSize*0.5
	inRel := (in - srcMid) * mapVec
	inLen := length(inRel)
	inLen2 := inLen * inLen
	outLen := inLen * (1.0 + inLen2*(CRTK1+inLen2*CRTK2))
	outRel := normalize(inRel) * outLen
	return srcMid + outRel/mapVec
}

func bayerM(srcOrigin, coord vec2) float {
	// Note: this should match FFmpeg's ordered_dither at bayer_scale=1.
	// Not using bayer_scale=0 primarily because it seems buggy in FFmpeg.
	/* const */
	bayerMap := [64]float{
		-16 / 255.0,
		8 / 255.0,
		-10 / 255.0,
		14 / 255.0,
		-15 / 255.0,
		9 / 255.0,
		-9 / 255.0,
		15 / 255.0,
		0 / 255.0,
		-8 / 255.0,
		6 / 255.0,
		-2 / 255.0,
		1 / 255.0,
		-7 / 255.0,
		7 / 255.0,
		-1 / 255.0,
		-12 / 255.0,
		12 / 255.0,
		-14 / 255.0,
		10 / 255.0,
		-11 / 255.0,
		13 / 255.0,
		-13 / 255.0,
		11 / 255.0,
		4 / 255.0,
		-4 / 255.0,
		2 / 255.0,
		-6 / 255.0,
		5 / 255.0,
		-3 / 255.0,
		3 / 255.0,
		-5 / 255.0,
		-15 / 255.0,
		9 / 255.0,
		-9 / 255.0,
		15 / 255.0,
		-16 / 255.0,
		8 / 255.0,
		-10 / 255.0,
		14 / 255.0,
		1 / 255.0,
		-7 / 255.0,
		7 / 255.0,
		-1 / 255.0,
		0 / 255.0,
		-8 / 255.0,
		6 / 255.0,
		-2 / 255.0,
		-11 / 255.0,
		13 / 255.0,
		-13 / 255.0,
		11 / 255.0,
		-12 / 255.0,
		12 / 255.0,
		-14 / 255.0,
		10 / 255.0,
		5 / 255.0,
		-3 / 255.0,
		3 / 255.0,
		-5 / 255.0,
		4 / 255.0,
		-4 / 255.0,
		2 / 255.0,
		-6 / 255.0,
	}

	p := imageSrcTextureSize() * (coord - srcOrigin)
	mPos := mod(floor(p), 8)
	mPosInt := int(mPos.x + 8*mPos.y)
	return bayerMap[mPosInt]
}

func egaAt(srcOrigin, coord vec2) vec4 {
	/* const */ colorMap := [16]vec4{
		vec4(0, 0, 0, 1),
		vec4(0, 0, 2/3.0, 1),
		vec4(0, 2/3.0, 0, 1),
		vec4(0, 2/3.0, 2/3.0, 1),
		vec4(2/3.0, 0, 0, 1),
		vec4(2/3.0, 0, 2/3.0, 1),
		vec4(2/3.0, 1/3.0, 0, 1),
		vec4(2/3.0, 2/3.0, 2/3.0, 1),
		vec4(1/3.0, 1/3.0, 1/3.0, 1),
		vec4(1/3.0, 1/3.0, 1, 1),
		vec4(1/3.0, 1, 1/3.0, 1),
		vec4(1/3.0, 1, 1, 1),
		vec4(1, 1/3.0, 1/3.0, 1),
		vec4(1, 1/3.0, 1, 1),
		vec4(1, 1, 1/3.0, 1),
		vec4(1, 1, 1, 1),
	}

	p := imageSrc0At(coord) + bayerM(srcOrigin, coord)

	best := colorMap[0]
	bestScore := length(p - best)
	for i := 1; i < 16; i++ {
		this := colorMap[i]
		score := length(p - this)
		if score < bestScore {
			best = this
			bestScore = score
		}
	}

	return best
}

func Fragment(position vec4, texCoord_ vec2, color vec4) vec4 {
	srcOrigin, srcSize := imageSrcRegionOnTexture()

	// Set up typical linear interpolation.
	srcImageSize := imageSrcTextureSize()

	// Map texture coordinate to CRT.
	texCoord := crtMap(srcOrigin, srcSize, srcImageSize, texCoord_)

	halfTexel := 0.5 / srcImageSize
	tieBreaker := halfTexel / 256.0
	topLeft := texCoord - halfTexel + tieBreaker
	bottomRight := texCoord + halfTexel + tieBreaker

	// Get the four texels (black for outside).
	a := egaAt(srcOrigin, topLeft)
	b := egaAt(srcOrigin, vec2(bottomRight.x, topLeft.y))
	c := egaAt(srcOrigin, vec2(topLeft.x, bottomRight.y))
	d := egaAt(srcOrigin, bottomRight)

	// Mix them properly.
	f := fract(topLeft * srcImageSize)

	// Reduce the blur to better match VGA-like scan line doubling.
	// With a factor of 2.0, we get 50% of the pixels as nearest and 50%
	// in the linear region. Also means that at 2x scaling or above, every
	// pixel value is guaranteed to occur unchanged _somewhere_.
	// When scaling 3x (from 360p to 1080p), this will change adjacent pixel
	// values of 0 1 to 0 1/6 5/6 1. The same can be done in ffmpeg by first
	// nearest-scaling to 2x then linear-scaling to 3x.
	f = clamp(0.5+(f-0.5)*2.0, 0.0, 1.0)

	// Scan line effect?
	row := texCoord.y * srcImageSize.y
	fRow := fract(row)
	fMask := 1.0 - abs(fRow-0.5)*ScanLineEffect
	mask := vec4(fMask, fMask, fMask, 1.0)
	return mix(mix(a, b, f.x), mix(c, d, f.x), f.y) * mask

	// Note: for 1080p (3x resolution), this will map every centeral pixel to full value,
	// but every other row to 1/3 its value.
	// We take that into account when generating the ffmpeg command.
}
